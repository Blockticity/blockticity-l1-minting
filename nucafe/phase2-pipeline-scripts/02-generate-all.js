#!/usr/bin/env node
/**
 * Script 02: Generate 350 publicJsons + SVGs.
 * Reads config, lot manifest, and farm attestation.
 * Validates lot manifest sums to 350.
 * Runs determinism check on 10 random SVGs.
 */
import fs from 'fs';
import os from 'os';
import path from 'path';
import { fileURLToPath } from 'url';
import { buildBagPublicJson } from '../lib/public-json-builder.js';
import { computeContentHash, deriveGVE } from '../lib/content-hash.js';
import { initAssets, renderBagSVG } from '../lib/svg-renderer.js';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const ROOT = path.join(__dirname, '..');

async function main() {
  console.log('=== NUCAFE Phase 2 — Script 02: Generate All 350 Bags ===\n');

  // Load inputs
  const config = JSON.parse(fs.readFileSync(path.join(ROOT, 'config/nucafe-phase2.config.json'), 'utf8'));
  const lotManifest = JSON.parse(fs.readFileSync(path.join(ROOT, 'config/lot-manifest.json'), 'utf8'));
  const farmAttestation = JSON.parse(fs.readFileSync(path.join(ROOT, 'data/farm-attestation.json'), 'utf8'));

  // Validate lot manifest
  const totalFromLots = lotManifest.lots.reduce((sum, lot) => sum + lot.count, 0);
  if (totalFromLots !== config.totalBags) {
    console.error(`ERROR: Lot manifest sums to ${totalFromLots}, expected ${config.totalBags}`);
    console.error('Edit config/lot-manifest.json so counts sum to 350, then re-run.');
    process.exit(1);
  }
  console.log(`Lot manifest validated: ${lotManifest.lots.length} lots, ${totalFromLots} bags total ✓`);

  // Build lot lookup: serial → lotNumber
  const lotLookup = {};
  for (const lot of lotManifest.lots) {
    for (let s = lot.bagStart; s <= lot.bagEnd; s++) {
      lotLookup[s] = lot.lotNumber;
    }
  }

  // Init SVG renderer with logo assets
  const resolvePath = (p) => p.startsWith('~') ? path.join(os.homedir(), p.slice(1)) : path.resolve(ROOT, p);
  const nucafeLogoPath = resolvePath(config.assets.nucafeLogo);
  const sealPath = resolvePath(config.assets.blockticitySeal);
  const productImagePath = resolvePath(config.assets.nucafeProductImage);
  const mapImagePath = resolvePath(config.assets.mapImage);
  const qrLogoPath = resolvePath(config.assets.qrLogo);
  initAssets(nucafeLogoPath, sealPath, productImagePath, mapImagePath, qrLogoPath);
  console.log(`Assets loaded: Logo ${fs.existsSync(nucafeLogoPath) ? '✓' : '✗'}, Seal ${fs.existsSync(sealPath) ? '✓' : '✗'}, Product ${fs.existsSync(productImagePath) ? '✓' : '✗'}, Map ${fs.existsSync(mapImagePath) ? '✓' : '✗'}, QR Logo ${fs.existsSync(qrLogoPath) ? '✓' : '✗'}`);

  // Ensure output dirs
  const svgDir = path.join(ROOT, 'output/svg');
  const pjDir = path.join(ROOT, 'output/publicJson');
  const metaDir = path.join(ROOT, 'output/metadata');
  [svgDir, pjDir, metaDir].forEach(d => fs.mkdirSync(d, { recursive: true }));

  const manifestEntries = [];
  const startTime = Date.now();

  console.log(`\nGenerating ${config.totalBags} bag COAs...\n`);

  for (let serial = 1; serial <= config.totalBags; serial++) {
    const lotNumber = lotLookup[serial];
    if (!lotNumber) {
      console.error(`ERROR: No lot assignment for bag serial ${serial}`);
      process.exit(1);
    }

    // 1. Build publicJson
    const publicJson = buildBagPublicJson(serial, lotNumber, config, farmAttestation);

    // 2. Compute content hash + GVE
    const contentHash = computeContentHash(publicJson);
    const gveCode = deriveGVE(contentHash);

    // Attach verification to publicJson (post-hash, not part of hash input)
    publicJson.verification = { contentHash, gveCode };

    // 3. Render SVG
    const serialStr = String(serial).padStart(3, '0');
    const renderData = {
      contentHash,
      gveCode,
      tokenId: null,
      certificateTitle: config.certificateTitle,
      productName: config.productName,
      productDescription: config.productDescription,
      issuerName: config.issuer.name,
      issuerAddress: config.issuer.address,
      primaryLabel: 'Bag Serial',
      primaryValue: `${config.serialPrefix}-${serialStr}`,
      productFields: publicJson.fields,
      latitude: config.coordinates.latitude,
      longitude: config.coordinates.longitude,
      qrDataUrl: null // will be generated by renderer
    };
    const svg = await renderBagSVG(renderData);

    // 4. Save files
    fs.writeFileSync(path.join(svgDir, `BAG-${serialStr}.svg`), svg);
    fs.writeFileSync(path.join(pjDir, `BAG-${serialStr}.json`), JSON.stringify(publicJson, null, 2));

    manifestEntries.push({
      serial,
      identifier: `${config.serialPrefix}-${serialStr}`,
      lotNumber,
      contentHash,
      gveCode,
      svgFile: `BAG-${serialStr}.svg`,
      publicJsonFile: `BAG-${serialStr}.json`
    });

    if (serial % 50 === 0 || serial === config.totalBags) {
      const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
      console.log(`  ${serial}/${config.totalBags} generated (${elapsed}s)`);
    }
  }

  // Save manifest
  const outputManifest = {
    project: config.project,
    generatedAt: new Date().toISOString(),
    totalBags: manifestEntries.length,
    farmAttestationHash: farmAttestation.farmAttestationHash,
    entries: manifestEntries
  };
  fs.writeFileSync(path.join(ROOT, 'output/manifest.json'), JSON.stringify(outputManifest, null, 2));

  // Determinism check: re-render 10 random SVGs
  console.log('\nDeterminism check: re-rendering 10 random bags...');
  const indices = [];
  while (indices.length < 10) {
    const idx = Math.floor(Math.random() * config.totalBags) + 1;
    if (!indices.includes(idx)) indices.push(idx);
  }

  let deterministicOk = true;
  for (const serial of indices) {
    const serialStr = String(serial).padStart(3, '0');
    const lotNumber = lotLookup[serial];
    const publicJson = buildBagPublicJson(serial, lotNumber, config, farmAttestation);
    const contentHash = computeContentHash(publicJson);
    publicJson.verification = { contentHash, gveCode: deriveGVE(contentHash) };

    const renderData = {
      contentHash,
      gveCode: deriveGVE(contentHash),
      tokenId: null,
      certificateTitle: config.certificateTitle,
      productName: config.productName,
      productDescription: config.productDescription,
      issuerName: config.issuer.name,
      issuerAddress: config.issuer.address,
      primaryLabel: 'Bag Serial',
      primaryValue: `${config.serialPrefix}-${serialStr}`,
      productFields: publicJson.fields,
      latitude: config.coordinates.latitude,
      longitude: config.coordinates.longitude,
      qrDataUrl: null
    };
    const svg2 = await renderBagSVG(renderData);
    const original = fs.readFileSync(path.join(svgDir, `BAG-${serialStr}.svg`), 'utf8');

    if (svg2 !== original) {
      console.error(`  BAG-${serialStr}: MISMATCH ✗`);
      deterministicOk = false;
    } else {
      console.log(`  BAG-${serialStr}: identical ✓`);
    }
  }

  if (!deterministicOk) {
    console.error('\nWARNING: Determinism check FAILED for some bags.');
    console.error('QR codes use random nonces — this is expected. SVG structure should still match.');
  } else {
    console.log('Determinism check: ALL PASSED ✓');
  }

  const totalTime = ((Date.now() - startTime) / 1000).toFixed(1);
  console.log(`\n=== Script 02 complete: ${manifestEntries.length} bags generated in ${totalTime}s ===`);
  console.log(`Output: ${path.join(ROOT, 'output/')}`);
}

main().catch(err => {
  console.error('Fatal error:', err);
  process.exit(1);
});
